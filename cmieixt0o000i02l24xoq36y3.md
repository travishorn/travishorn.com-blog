---
title: "From Auto-Increments to UUID v7"
datePublished: Tue Nov 25 2025 12:00:28 GMT+0000 (Coordinated Universal Time)
cuid: cmieixt0o000i02l24xoq36y3
slug: from-auto-increments-to-uuid-v7
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1764015469962/b30615c4-b4df-43e0-93e9-b1b9d866d913.png
tags: backend, databases, uuid, sql, mariadb, data-modeling, primary-key, ulid, uuidv7, database-performance

---

When picking a primary key for a database table, there is sometimes an obvious choice. If you’re creating a table of users and they authenticate using email addresses, you might be tempted to use the email address as the primary key since it is unique to each user.

However, this "natural key" strategy has drawbacks. For instance, if a user wants to change their email address, you have to update the primary key. While you can cascade that change to related tables, you effectively lose the historical link between the old email and the new one. If alice@example.com becomes bob@example.com, the database no longer inherently knows that "Bob" used to be "Alice."

Furthermore, using personal information as an identifier creates issues in URLs. A structure like example.com/user/bob@example.com not only exposes the user's email address in possibly undesired ways but also requires careful character escaping.

For these reasons, database administrators and developers often use a unique identifier generated by the database itself. This is called a surrogate key.

## The Auto-Incrementing Integer

The most common surrogate key strategy is the auto-incrementing integer. It offers many benefits. For one, the identifier never changes. A user assigned ID `7` remains `7` regardless of email changes, username updates, or account deactivation.

Another benefit is that integers take up very little storage space compared to other unique identifiers.

Also, because the IDs are sequential, you can sort by them to approximate sorting by creation time.

However, auto-incrementing IDs are predictable. If your application uses a URL like example.com/document/237, users might guess that they can access other records by visiting example.com/document/236 or 238.

There is also a less obvious operational risk. I have a specific story that highlights why I moved away from auto-incrementing integers for certain tables.

## The Corruption Incident

Years ago, a production database I was working on got corrupted. To restore service as quickly as possible, I restored a backup from an earlier point in time. While we got the application back online quickly, we were still working in the background to recover the data generated after that backup was taken.

Meanwhile, the live application began creating new records. Because the primary keys were auto-incrementing integers, the database restored the counter based on the older backup. The new rows began claiming IDs (e.g., 1001, 1002) that had already been assigned to the "lost" data we were trying to recover.

When it came time to merge the recovered data back in, we faced a massive conflict. We had duplicate IDs for different records, leading to a painful manual correction process.

## Enter UUID v4

After that incident, I started defaulting to UUIDs (specifically v4) as my primary key when it made sense. These are randomly generated 128-bit identifiers with an astronomically low collision rate. You can generate as many as you need, as fast as you need, and virtually never generate the same identifier twice.

UUIDs solve the predictability issue and the "restore conflict" issue. However, they introduce new problems. Since they are 128-bit, they’re four times larger than a standard integer.

They also fragment your indexes. Because UUID v4 is completely random, the database cannot append new records to the end of the index. Instead, it must insert the ID into a random location in the B-tree.

This random insertion causes page splitting, which significantly increases disk I/O and hurts write performance as your table grows.

## Now, UUID v7

In September 2024, MariaDB released version 11.7, introducing native support for UUID v7. Since then, I’ve switched my default strategy from UUID v4 to v7.

Why? UUID v7 adds order to the randomness.

With UUID v7, the current timestamp is encoded into the beginning of the ID. This means new IDs are always "greater" than previous ones. They are appended to the end of the index, preventing the performance penalty of v4 while retaining collision safety.

Because the creation time is encoded in the identifier, we also get a secondary benefit: we no longer need a separate `created_at` column.

## A Warning on Data Leakage

One of the biggest drawbacks to UUID v7 is data leakage. Because the timestamp is baked into the ID, anyone with the ID can decode exactly when the record was created.

If leaking the exact creation time of a record is a security risk for your specific application, do not use UUID v7. If that is not a concern, consider if making the switch is right for you.

## Implementation

Here is how you might define a user table with an integer `id`:

```sql
CREATE TABLE users (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  -- Creation time tracked separately from identifier above
  created_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  email_address VARCHAR(255) NOT NULL,
  PRIMARY KEY (id)
);
```

And here’s how you might do it with UUID v4:

```sql
CREATE TABLE users (
  -- Application logic must generate the UUID v4 in older versions of MariaDB
  id UUID NOT NULL,
  created_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  email_address VARCHAR(255) NOT NULL,
  PRIMARY KEY (id)
);
```

Now, in MariaDB 11.7 and beyond, you can define tables like this:

```sql
CREATE TABLE users (
  id UUID NOT NULL DEFAULT (uuid_v7()),
  created_at DATETIME(3) GENERATED ALWAYS AS (
    FROM_UNIXTIME(
      CONV(LEFT(HEX(id), 12), 16, 10) /1000
    )
  ) VIRTUAL,
  email_address VARCHAR(255) NOT NULL,
  PRIMARY KEY (id)
);
```

The `created_at` column is now a virtual column. It is calculated on the fly from the `id`, saving disk space and ensuring the timestamp never drifts from the ID.

## How that Virtual Column Works

That `created_at` definition looks complex, but here is what is happening under the hood:

1. `HEX(id)` converts the binary UUID (which is stored as 16 bytes) into a hexadecimal string.
    
2. `LEFT(..., 12)` grabs the first 12 hex characters. In UUID v7, the first 48 bits (12 hex chars) represent the timestamp.
    
3. `CONV(..., 16, 10)` converts that hex string (base-16) string into a decimal number (base-10).
    
4. `/ 1000` converts the milliseconds into seconds (which is what `FROM_UNIXTIME` expects).
    
5. `FROM_UNIXTIME(...)` converts the seconds into a standard `DATETIME` format.
    

## The Result

When you insert data, you no longer worry about the ID or the timestamp:

```sql
INSERT INTO users (email_address) VALUES ('travis@travishorn.com');
SELECT * FROM users;
```

Check out what the inserted data looks like.

<table><tbody><tr><td colspan="1" rowspan="1"><p><strong>id</strong></p></td><td colspan="1" rowspan="1"><p><strong>created_at</strong></p></td><td colspan="1" rowspan="1"><p><strong>email_address</strong></p></td></tr><tr><td colspan="1" rowspan="1"><p>019ab724-0057-7718-94b7-ba6587014141</p></td><td colspan="1" rowspan="1"><p>2025-11-24 12:33:01.270</p></td><td colspan="1" rowspan="1"><p>travis@travishorn.com</p></td></tr></tbody></table>

Here’s something cool: even though `created_at` is virtual and not stored on disk, MariaDB still allows you to index it if you need to. If you add an index to that column, the calculated values are persisted in the index tree, making queries fast.

But honestly, you might not need to. Since UUID v7 is time-ordered, you can simply sort by the primary key to get the correct chronological order:

```sql
SELECT * FROM users ORDER BY id;
```

UUID v7 gives us the best of both worlds: the scalability and uniqueness of UUIDs, with the performance and sorting benefits of integers.

## ULID and Standardization

If you’ve dealt with the random UUID problem before, and you’ve researched some solutions, you might be thinking, "this sounds exactly like ULID."

You’re right. ULIDs (Universally Unique Lexicographically Sortable Identifiers) have been available to developers for years. Like UUID v7, a ULID puts the timestamp at the beginning of the identifier to ensure it sorts correctly and doesn't fragment database indexes.

UUID v7 is the standardization of this same concept.

While ULID became a popular community solution, UUID v7 is part of the official RFC 9562 specification. Since this standard, database vendors like MariaDB, PostgreSQL, and MongoDB have rolled out native optimizations for it. While ULID often requires storing identifiers as 26-character strings or using custom binary implementations, UUID v7 fits perfectly into the existing, highly optimized 128-bit UUID data type that databases have supported for a long time now.

## Conclusion

There’s never a one-size-fits-all solution in database design, but UUID v7 is a great solution in many cases. It combines most of the safety of unique, random IDs with some of the performance of sequential integers. If you’re running a DBMS that supports it, you may also consider giving it a try.

Photo by [Red Zeppelin](https://unsplash.com/@redzeppelin?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/photos/orange-sediment-cloud-mixes-with-deep-blue-ocean-water-xHpyGeeNsAs?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText).